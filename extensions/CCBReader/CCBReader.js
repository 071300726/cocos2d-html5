/****************************************************************************
 Copyright (c) 2010-2012 cocos2d-x.org
 Copyright (c) 2008-2010 Ricardo Quesada
 Copyright (c) 2011      Zynga Inc.

 http://www.cocos2d-x.org

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.
 ****************************************************************************/

var kCCBVersion = 2;

var kCCBPropTypePosition = 0;
var kCCBPropTypeSize = 1;
var kCCBPropTypePoint = 2;
var kCCBPropTypePointLock = 3;
var kCCBPropTypeScaleLock = 4;
var kCCBPropTypeDegrees = 5;
var kCCBPropTypeInteger = 6;
var kCCBPropTypeFloat = 7;
var kCCBPropTypeFloatVar = 8;
var kCCBPropTypeCheck = 9;
var kCCBPropTypeSpriteFrame = 10;
var kCCBPropTypeTexture = 11;
var kCCBPropTypeByte = 12;
var kCCBPropTypeColor3 = 13;
var kCCBPropTypeColor4FVar = 14;
var kCCBPropTypeFlip = 15;
var kCCBPropTypeBlendFunc = 16;
var kCCBPropTypeFntFile = 17;
var kCCBPropTypeText = 18;
var kCCBPropTypeFontTTF = 19;
var kCCBPropTypeIntegerLabeled = 20;
var kCCBPropTypeBlock = 21;
var kCCBPropTypeAnimation = 22;
var kCCBPropTypeCCBFile = 23;
var kCCBPropTypeString = 24;
var kCCBPropTypeBlockCCControl = 25;
var kCCBPropTypeFloatScale = 26;

var kCCBFloat0 = 0;
var kCCBFloat1 = 1;
var kCCBFloatMinus1 = 2;
var kCCBFloat05 = 3;
var kCCBFloatInteger = 4;
var kCCBFloatFull = 5;

var kCCBPlatformAll = 0;
var kCCBPlatformIOS = 1;
var kCCBPlatformMac = 2;

var kCCBTargetTypeNone = 0;
var kCCBTargetTypeDocumentRoot = 1;
var kCCBTargetTypeOwner = 2;

var kCCBPositionTypeRelativeBottomLeft = 0;
var kCCBPositionTypeRelativeTopLeft = 1;
var kCCBPositionTypeRelativeTopRight = 2;
var kCCBPositionTypeRelativeBottomRight = 3;
var kCCBPositionTypePercent = 4;

var kCCBSizeTypeAbsolute = 0;
var kCCBSizeTypePercent = 1;
var kCCBSizeTypeRelativeContainer = 2;
var kCCBSizeTypeHorizontalPercent = 3;
var kCCBSzieTypeVerticalPercent = 4;

var kCCBScaleTypeAbsolute = 0;
var kCCBScaleTypeMultiplyResolution = 1;

/**
 * Parse CCBI file which is generated by CocosBuilder
 */
cc.CCBReader = cc.Class.extend({
    _ccbRootPath:null,
    _rootCCBReader:false,

    _bytes:0,
    _currentByte:0,
    _currentBit:0,
    _owner:null,
    _rootNode:null,
    _rootContainerSize:null,
    _resolutionScale:0,

    _ccNodeLoaderLibrary:null,
    _ccNodeLoaderListener:null,
    _ccbMemberVariableAssigner:null,
    _ccbSelectorResolver:null,

    _stringCache:null,
    _loadedSpriteSheets:null,

    ctor:function(ccNodeLoaderLibrary,ccbMemberVariableAssigner,ccbSelectorResolver,ccNodeLoaderListener){
        if(arguments.length == 1){
            var ccbReader =  ccNodeLoaderLibrary;
            this._rootNode = null;
            this._rootCCBReader = false;

            /* Borrow data from the 'parent' CCBReader. */
            this._resolutionScale = ccbReader._resolutionScale;
            this._loadedSpriteSheets = ccbReader._loadedSpriteSheets;
            this._ccNodeLoaderLibrary = ccbReader._ccNodeLoaderLibrary;

            this._ccbMemberVariableAssigner = ccbReader._ccbMemberVariableAssigner;
            this._ccbSelectorResolver = ccbReader._ccbSelectorResolver;
            this._ccNodeLoaderListener = ccbReader._ccNodeLoaderListener;
        }else{
            this._rootNode = null;
            this._rootCCBReader = true;

            this._ccNodeLoaderLibrary = ccNodeLoaderLibrary;
            this._ccbMemberVariableAssigner = ccbMemberVariableAssigner;
            this._ccbSelectorResolver = ccbSelectorResolver;
            this._ccNodeLoaderListener = ccNodeLoaderListener;

            this._resolutionScale = 1;
        }
    },

    readNodeGraphFromFile:function(ccbRootPath,ccbFileName,owner,rootContainerSize){
        rootContainerSize = rootContainerSize || cc.Director.getInstance().getWinSize();

        this._ccbRootPath = ccbRootPath;

        var ccbFullFilePath = cc.CCBReader.concat(ccbRootPath, ccbFileName);

        var path = cc.FileUtils.getInstance().fullPathFromRelativePath(ccbFullFilePath);

        var size = 0;
        this._bytes = cc.FileUtils.getInstance().getFileData(path, "rb", size);

        this._currentByte = 0;
        this._currentBit = 0;

        this._owner = owner;
        this._rootContainerSize = rootContainerSize;

        var node = null;
        if(this._readHeader() && this._readStringCache()) {
            node = this._readNodeGraph();
        }
        return node;
    },

    getCCBMemberVariableAssigner:function(){
        return this._ccbMemberVariableAssigner;
    },

    getCCBSelectorResolver:function(){
        return this._ccbSelectorResolver;
    },

    getCCBRootPath:function(){
        return this._ccbRootPath;
    },

    getOwner:function(){
        return this._owner;
    },

    getRootNode:function(){
        return this._rootNode;
    },

    getContainerSize:function(node){
        if(node) {
            return node.getContentSize();
        } else {
            return this._rootContainerSize;
        }
    },

    getResolutionScale:function(){
        return this._resolutionScale;
    },

    isSpriteSheetLoaded:function(spriteSheet){
        return this._loadedSpriteSheets.indexOf(spriteSheet) > -1;
    },

    addLoadedSpriteSheet:function(spriteSheet){
        // Since std::set<string> will copy the string from pSpriteSheet, we needn't to retain 'pSpriteSheet'.
        //    pSpriteSheet.retain();
        this._loadedSpriteSheets.push(spriteSheet);
    },

    readInt:function(signed){
        var numBits = 0;
        while(!this._getBit()) {
            numBits++;
        }

        var current = 0;
        for(var a = numBits - 1; a >= 0; a--) {
            if(this._getBit()) {
                current |= 1 << a;
            }
        }
        current |= 1 << numBits;

        var num;
        if(signed) {
            var s = current % 2;
            if(s) {
                num = current / 2;
            } else {
                num = -current / 2;
            }
        } else {
            num = current - 1;
        }

        this._alignBits();

        return num;
    },

    readByte:function(){
        var byteValue = this._bytes[this._currentByte];
        this._currentByte++;
        return byteValue;
    },

    readBool:function(){
        return (0 != this.readByte());
    },

    readFloat:function(){
        var type = this.readByte();

        switch (type) {
            case kCCBFloat0:
                return 0;
            case kCCBFloat1:
                return 1;
            case kCCBFloatMinus1:
                return -1;
            case kCCBFloat05:
                return 0.5;
            case kCCBFloatInteger:
                return this.readInt(true);
            default:
                /* using a memcpy since the compiler isn't
                 * doing the float ptr math correctly on device.
                 * TODO still applies in C++ ? */
                var pF = this._bytes + this._currentByte;
                this._currentByte += 4;
                return pF;
        }
    },

    readCachedString:function(){
        var i = this.readInt(false);
        return this._stringCache[i];
    },

    _readHeader:function(){
        /* If no bytes loaded, don't crash about it. */
        if(this._bytes == null) {
            return false;
        }

        /* Read magic bytes */
        var magicBytes = this._bytes[this._currentByte];
        this._currentByte += 4;

        if(CC_SWAP_INT32_LITTLE_TO_HOST(magicBytes) != 'ccbi') {
            return false;
        }

        /* Read version. */
        var version = this.readInt(false);
        if(version != kCCBVersion) {
            cc.log("WARNING! Incompatible ccbi file version (file: " + version + " reader: " + kCCBVersion + ")");
            return false;
        }

        return true;
    },

    _readStringCache:function(){
        var numStrings = this.readInt(false);

        for(var i = 0; i < numStrings; i++) {
            this._readStringCacheEntry();
        }

        return true;
    },

    _readStringCacheEntry:function(){
        var b0 = this.readByte();
        var b1 = this.readByte();

        var numBytes = b0 << 8 | b1;

        var str = "";
        for(var i = 0 ; i< numBytes;i++){
            str += String.fromCharCode(this._bytes[this._currentByte + i]);
        }

        this._currentByte += numBytes;
        this._stringCache.push(str);
    },

    _readNodeGraph:function(parent){
        /* Read class name. */
        var className = this.readCachedString();

        var memberVarAssignmentType = this.readInt(false);
        var memberVarAssignmentName;
        if(memberVarAssignmentType != kCCBTargetTypeNone) {
            memberVarAssignmentName = this.readCachedString();
        }

        var ccNodeLoader = this._ccNodeLoaderLibrary.getCCNodeLoader(className);
        var node = ccNodeLoader.loadCCNode(parent, this);

        /* Set root node, if not set yet. */
        if(this._rootNode == null) {
            this._rootNode = node;
        }

        if(memberVarAssignmentType != kCCBTargetTypeNone) {
            var target = null;
            if(memberVarAssignmentType == kCCBTargetTypeDocumentRoot) {
                target = this._rootNode;
            } else if(memberVarAssignmentType == kCCBTargetTypeOwner) {
                target = this._owner;
            }

            if(target != null) {
                var assigned = false;

                //var targetAsCCBMemberVariableAssigner = dynamic_cast<CCBMemberVariableAssigner *>(target);
                var targetAsCCBMemberVariableAssigner = target;

                if(targetAsCCBMemberVariableAssigner != null) {
                    assigned = targetAsCCBMemberVariableAssigner.onAssignCCBMemberVariable(target, memberVarAssignmentName, node);
                }

                if(!assigned && this._ccbMemberVariableAssigner != null) {
                    this._ccbMemberVariableAssigner.onAssignCCBMemberVariable(target, memberVarAssignmentName, node);
                }
            }
        }

        /* Read and add children. */
        var numChildren = this.readInt(false);
        for(var i = 0; i < numChildren; i++) {
            var child = this._readNodeGraph(node);
            node.addChild(child);
        }

        //var nodeAsCCNodeLoaderListener = dynamic_cast<CCNodeLoaderListener *>(node);
        var nodeAsCCNodeLoaderListener = node;
        if(nodeAsCCNodeLoaderListener != null) {
            nodeAsCCNodeLoaderListener.onNodeLoaded(node, ccNodeLoader);
        } else if(this._ccNodeLoaderListener != null) {
            this._ccNodeLoaderListener.onNodeLoaded(node, ccNodeLoader);
        }

        return node;
    },

    _getBit:function(){
        var bit;
        var byte = this._bytes[this._currentByte];
        if(byte & (1 << this._currentBit)) {
            bit = true;
        } else {
            bit = false;
        }

        this._currentBit++;

        if(this._currentBit >= 8) {
            this._currentBit = 0;
            this._currentByte++;
        }

        return bit;
    },
    _alignBits:function(){
        if(this._currentBit) {
            this._currentBit = 0;
            this._currentByte++;
        }
    },
    _readUTF8:function(){}
});

cc.CCBReader.lastPathComponent = function(pathStr){
    var slashPos = pathStr.lastIndexOf("/");
    if(slashPos != -1) {
        return pathStr.substring(slashPos + 1, pathStr.length - slashPos);
    }
    return pathStr;
};

cc.CCBReader.deletePathExtension = function(pathStr){
    var dotPos = pathStr.lastIndexOf(".");
    if(dotPos != -1) {
        return CCString::create(path.substr(0, dotPos).c_str());
    }
    return pathStr;
};

cc.CCBReader.toLowerCase = function(sourceStr){
    return sourceStr.toLowerCase();
};

cc.CCBReader.endsWith = function(sourceStr,ending){
    if(sourceStr.length >= ending.length)
        return (sourceStr.lastIndexOf(ending) == 0);
    else
        return false;
};

cc.CCBReader.concat = function(stringA,stringB){
    return stringA + stringB;
};

